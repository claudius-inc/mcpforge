// GitHub integration — push generated MCP servers to repos

export interface GitHubPushParams {
  accessToken: string;
  repoName: string;
  repoDescription?: string;
  isPrivate?: boolean;
  files: { path: string; content: string }[];
  commitMessage?: string;
}

export interface GitHubPushResult {
  repoUrl: string;
  commitSha: string;
  created: boolean;
}

/**
 * Create (or update) a GitHub repo with generated MCP server files.
 * Uses GitHub REST API directly — no SDK needed.
 */
export async function pushToGitHub(params: GitHubPushParams): Promise<GitHubPushResult> {
  const { accessToken, repoName, repoDescription, isPrivate = true, files, commitMessage = 'Generate MCP server via MCPForge' } = params;

  const headers = {
    'Authorization': `Bearer ${accessToken}`,
    'Accept': 'application/vnd.github+json',
    'X-GitHub-Api-Version': '2022-11-28',
    'Content-Type': 'application/json',
  };

  // 1. Get authenticated user
  const userRes = await fetch('https://api.github.com/user', { headers });
  if (!userRes.ok) throw new Error('GitHub auth failed');
  const user = await userRes.json();
  const owner = user.login;

  // 2. Try to get existing repo
  let created = false;
  const repoRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}`, { headers });

  if (repoRes.status === 404) {
    // Create new repo
    const createRes = await fetch('https://api.github.com/user/repos', {
      method: 'POST',
      headers,
      body: JSON.stringify({
        name: repoName,
        description: repoDescription || 'MCP server generated by MCPForge',
        private: isPrivate,
        auto_init: true,
      }),
    });

    if (!createRes.ok) {
      const err = await createRes.json();
      throw new Error(`Failed to create repo: ${err.message || createRes.statusText}`);
    }
    created = true;

    // Wait briefly for initialization
    await new Promise(r => setTimeout(r, 1500));
  } else if (!repoRes.ok) {
    throw new Error('Failed to check repo');
  }

  // 3. Get current default branch ref
  const refRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/refs/heads/main`, { headers });

  let baseSha: string;
  if (refRes.ok) {
    const ref = await refRes.json();
    baseSha = ref.object.sha;
  } else {
    // Try 'master' branch
    const masterRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/refs/heads/master`, { headers });
    if (!masterRes.ok) throw new Error('Cannot find default branch');
    const ref = await masterRes.json();
    baseSha = ref.object.sha;
  }

  // 4. Create blobs for each file
  const blobShas: { path: string; sha: string }[] = [];
  for (const file of files) {
    const blobRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/blobs`, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        content: file.content,
        encoding: 'utf-8',
      }),
    });
    if (!blobRes.ok) throw new Error(`Failed to create blob for ${file.path}`);
    const blob = await blobRes.json();
    blobShas.push({ path: file.path, sha: blob.sha });
  }

  // 5. Create tree
  const treeRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/trees`, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      base_tree: baseSha,
      tree: blobShas.map(b => ({
        path: b.path,
        mode: '100644',
        type: 'blob',
        sha: b.sha,
      })),
    }),
  });
  if (!treeRes.ok) throw new Error('Failed to create tree');
  const tree = await treeRes.json();

  // 6. Create commit
  const commitRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/commits`, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      message: commitMessage,
      tree: tree.sha,
      parents: [baseSha],
    }),
  });
  if (!commitRes.ok) throw new Error('Failed to create commit');
  const commit = await commitRes.json();

  // 7. Update ref
  const updateRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/refs/heads/main`, {
    method: 'PATCH',
    headers,
    body: JSON.stringify({ sha: commit.sha }),
  });

  if (!updateRes.ok) {
    // Try master
    await fetch(`https://api.github.com/repos/${owner}/${repoName}/git/refs/heads/master`, {
      method: 'PATCH',
      headers,
      body: JSON.stringify({ sha: commit.sha }),
    });
  }

  return {
    repoUrl: `https://github.com/${owner}/${repoName}`,
    commitSha: commit.sha,
    created,
  };
}

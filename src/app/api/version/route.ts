import { NextRequest, NextResponse } from 'next/server';
import { compareVersions, VersionError } from '@/lib/versioning/compare';
import { generateTypeScriptServer } from '@/lib/generator/typescript';
import { generatePythonServer } from '@/lib/generator/python';
import { createZipBundle } from '@/lib/output/zip-bundle';

/**
 * POST /api/version
 * Compare two OpenAPI specs and optionally download the updated MCP server.
 *
 * Body: {
 *   oldSpec: string,       // Previous OpenAPI spec (YAML/JSON)
 *   newSpec: string,       // Updated OpenAPI spec (YAML/JSON)
 *   target?: "typescript" | "python",
 *   mode?: "diff" | "download",   // diff = just return the diff, download = updated ZIP
 *   disabledTools?: string[],
 * }
 */
export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const {
      oldSpec,
      newSpec,
      target = 'typescript',
      mode = 'diff',
      disabledTools = [],
    } = body;

    // Validate inputs
    if (!oldSpec || typeof oldSpec !== 'string') {
      return NextResponse.json(
        { error: 'Missing or invalid "oldSpec" field.' },
        { status: 400 }
      );
    }
    if (!newSpec || typeof newSpec !== 'string') {
      return NextResponse.json(
        { error: 'Missing or invalid "newSpec" field.' },
        { status: 400 }
      );
    }
    if (!['typescript', 'python'].includes(target)) {
      return NextResponse.json(
        { error: 'Invalid target. Must be "typescript" or "python".' },
        { status: 400 }
      );
    }
    if (!['diff', 'download'].includes(mode)) {
      return NextResponse.json(
        { error: 'Invalid mode. Must be "diff" or "download".' },
        { status: 400 }
      );
    }

    // Compare
    const result = compareVersions({ oldSpec, newSpec, disabledTools });

    // Diff mode: return structured diff
    if (mode === 'diff') {
      return NextResponse.json({
        success: true,
        diff: result.diff,
        oldServer: {
          name: result.oldConfig.name,
          version: result.oldConfig.version,
          toolCount: result.oldConfig.tools.length,
        },
        newServer: {
          name: result.newConfig.name,
          version: result.newConfig.version,
          toolCount: result.newConfig.tools.length,
          tools: result.newConfig.tools.map(t => ({
            name: t.name,
            description: t.description,
            enabled: t.enabled,
            source: t.source,
          })),
          envVars: result.newConfig.envVars,
        },
      });
    }

    // Download mode: generate updated server
    const files = target === 'typescript'
      ? generateTypeScriptServer(result.newConfig)
      : generatePythonServer(result.newConfig);

    // Inject migration notes as MIGRATION.md
    if (result.diff.changes.length > 0) {
      files['MIGRATION.md'] = generateMigrationDoc(result);
    }

    const folderName = `mcp-${result.newConfig.name}`;
    const zipBuffer = await createZipBundle(files, folderName);

    return new NextResponse(new Uint8Array(zipBuffer), {
      status: 200,
      headers: {
        'Content-Type': 'application/zip',
        'Content-Disposition': `attachment; filename="${folderName}-updated.zip"`,
        'Content-Length': String(zipBuffer.length),
      },
    });
  } catch (error) {
    if (error instanceof VersionError) {
      return NextResponse.json(
        { error: error.message, details: error.details },
        { status: 400 }
      );
    }
    console.error('Version compare error:', error);
    return NextResponse.json(
      { error: 'Internal server error', message: (error as Error).message },
      { status: 500 }
    );
  }
}

/**
 * Generate a MIGRATION.md document for the updated server.
 */
function generateMigrationDoc(result: { diff: ReturnType<typeof import('@/lib/versioning/differ').diffConfigs>; oldConfig: { name: string; version: string }; newConfig: { name: string; version: string } }): string {
  const { diff, oldConfig, newConfig } = result;
  const lines: string[] = [
    `# Migration Guide: ${oldConfig.version} â†’ ${newConfig.version}`,
    '',
    `> Auto-generated by [MCPForge](https://mcpforge.dev)`,
    '',
    `## Summary`,
    '',
    diff.summary,
    '',
  ];

  if (diff.migrationNotes.length > 0) {
    lines.push('## âš ï¸ Migration Notes', '');
    for (const note of diff.migrationNotes) {
      lines.push(`- ${note}`);
    }
    lines.push('');
  }

  // Group changes by kind
  const added = diff.changes.filter(c => c.kind === 'tool_added');
  const removed = diff.changes.filter(c => c.kind === 'tool_removed');
  const modified = diff.changes.filter(c => c.kind === 'tool_modified');
  const envChanges = diff.changes.filter(c => c.kind === 'env_added' || c.kind === 'env_removed');

  if (added.length > 0) {
    lines.push('## âœ… New Tools', '');
    for (const c of added) {
      lines.push(`- **${c.toolName}** â€” ${c.description.replace(/^New tool: \w+ â€” /, '')}`);
    }
    lines.push('');
  }

  if (removed.length > 0) {
    lines.push('## âŒ Removed Tools', '');
    for (const c of removed) {
      lines.push(`- **${c.toolName}** â€” ${c.description.replace(/^Removed tool: \w+ â€” /, '')}`);
    }
    lines.push('');
  }

  if (modified.length > 0) {
    lines.push('## ðŸ”„ Modified Tools', '');
    for (const c of modified) {
      lines.push(`### ${c.toolName}`);
      if (c.details) {
        for (const d of c.details) {
          if (d.oldValue && d.newValue) {
            lines.push(`- **${d.field}**: \`${d.oldValue}\` â†’ \`${d.newValue}\``);
          } else if (d.newValue) {
            lines.push(`- **${d.field}**: ${d.newValue}`);
          } else if (d.oldValue) {
            lines.push(`- **${d.field}**: ${d.oldValue} (removed)`);
          }
        }
      }
      lines.push('');
    }
  }

  if (envChanges.length > 0) {
    lines.push('## ðŸ”‘ Environment Variable Changes', '');
    for (const c of envChanges) {
      const icon = c.kind === 'env_added' ? 'âž•' : 'âž–';
      lines.push(`- ${icon} ${c.description}`);
    }
    lines.push('');
  }

  return lines.join('\n');
}
